#Requires -Version 5.1
<#
.SYNOPSIS
    CLAUDE.md Auto-Init: Content Validator
.DESCRIPTION
    Validates generated CLAUDE.md and AGENT.md content for quality and security.
    Checks for required sections, unreplaced placeholders, and potential secrets.
.PARAMETER GeneratorResultJson
    JSON output from generator.ps1 (via pipeline or parameter)
.OUTPUTS
    JSON object with validation result, errors, and warnings
.EXAMPLE
    .\scanner.ps1 | .\selector.ps1 | .\gather.ps1 | .\generator.ps1 | .\validator.ps1
#>

param(
    [Parameter(ValueFromPipeline=$true)]
    [string]$GeneratorResultJson
)

# Read from stdin if not provided as parameter
if (-not $GeneratorResultJson) {
    $GeneratorResultJson = [Console]::In.ReadToEnd()
}

# Parse generator result
try {
    $generatorResult = $GeneratorResultJson | ConvertFrom-Json -ErrorAction Stop
}
catch {
    Write-Error "Failed to parse generator result JSON: $_"
    exit 1
}

# Initialize validation result
$errors = @()
$warnings = @()

#region CLAUDE.md Validation

if ($generatorResult.claudeMdContent) {
    $content = $generatorResult.claudeMdContent

    # Check 1: Required sections
    $requiredSections = @(
        "# PROJECT MEMORY",
        "## Project Overview",
        "## Tech Stack",
        "## Coding Preferences"
    )

    foreach ($section in $requiredSections) {
        if ($content -notmatch [regex]::Escape($section)) {
            $errors += "CLAUDE.md missing required section: $section"
        }
    }

    # Check 2: Unreplaced placeholders
    $placeholderPattern = '\{\{[A-Z_]+\}\}'
    $matches = [regex]::Matches($content, $placeholderPattern)

    if ($matches.Count -gt 0) {
        $unreplacedPlaceholders = $matches | ForEach-Object { $_.Value } | Select-Object -Unique
        $warnings += "CLAUDE.md has unreplaced placeholders: $($unreplacedPlaceholders -join ', ')"
    }

    # Check 3: Secret patterns
    $secretPatterns = @(
        @{ Pattern = 'sk-[a-zA-Z0-9]{20,}'; Name = 'OpenAI API key' },
        @{ Pattern = 'pk_[a-zA-Z0-9]{20,}'; Name = 'Stripe key' },
        @{ Pattern = 'ghp_[a-zA-Z0-9]{36}'; Name = 'GitHub Personal Access Token' },
        @{ Pattern = 'xoxb-[0-9]{10,}-[a-zA-Z0-9]{24,}'; Name = 'Slack Bot Token' },
        @{ Pattern = 'AIza[a-zA-Z0-9_-]{35}'; Name = 'Google API key' },
        @{ Pattern = 'AKIA[A-Z0-9]{16}'; Name = 'AWS Access Key' },
        @{ Pattern = '(password|secret|api_key|token)\s*[:=]\s*["\x27]([^"\x27\s]{8,})["\x27]'; Name = 'Generic secret' }
    )

    foreach ($secretPattern in $secretPatterns) {
        if ($content -match $secretPattern.Pattern) {
            $errors += "CLAUDE.md contains potential secret: $($secretPattern.Name)"
        }
    }

    # Check 4: Markdown validity (basic check)
    # Check for common markdown errors
    $codeBlockPattern = '```'
    $codeBlockCount = ([regex]::Matches($content, [regex]::Escape($codeBlockPattern))).Count

    if ($codeBlockCount % 2 -ne 0) {
        $warnings += "CLAUDE.md has unbalanced code blocks (``` count is odd)"
    }

    # Check 5: File length (shouldn't be too short or too long)
    $lines = $content -split "`n"
    $lineCount = $lines.Count

    if ($lineCount -lt 20) {
        $warnings += "CLAUDE.md seems too short ($lineCount lines)"
    }
    elseif ($lineCount -gt 1000) {
        $warnings += "CLAUDE.md is very long ($lineCount lines) - consider breaking into sections"
    }

    # Check 6: Ensure auto-generated footer is present
    if ($content -notmatch 'Auto-generated by CLAUDE\.md Auto-Init System') {
        $warnings += "CLAUDE.md missing auto-generated footer"
    }
}
else {
    $errors += "No CLAUDE.md content generated"
}

#endregion

#region AGENT.md Validation

if ($generatorResult.agentMdContent) {
    $agentContent = $generatorResult.agentMdContent

    # Check 1: Required header
    if ($agentContent -notmatch '# AGENT') {
        $errors += "AGENT.md missing required # AGENT header"
    }

    # Check 2: Unreplaced placeholders
    $matches = [regex]::Matches($agentContent, $placeholderPattern)

    if ($matches.Count -gt 0) {
        $unreplacedPlaceholders = $matches | ForEach-Object { $_.Value } | Select-Object -Unique
        $warnings += "AGENT.md has unreplaced placeholders: $($unreplacedPlaceholders -join ', ')"
    }

    # Check 3: Secret patterns (same as CLAUDE.md)
    foreach ($secretPattern in $secretPatterns) {
        if ($agentContent -match $secretPattern.Pattern) {
            $errors += "AGENT.md contains potential secret: $($secretPattern.Name)"
        }
    }

    # Check 4: Code block balance
    $codeBlockCount = ([regex]::Matches($agentContent, [regex]::Escape($codeBlockPattern))).Count

    if ($codeBlockCount % 2 -ne 0) {
        $warnings += "AGENT.md has unbalanced code blocks (``` count is odd)"
    }
}

#endregion

# Determine if validation passed
$isValid = ($errors.Count -eq 0)

# Build validation result
$validationResult = @{
    isValid = $isValid
    errors = $errors
    warnings = $warnings
    checks = @{
        claudeMd = @{
            requiredSections = ($errors | Where-Object { $_ -like "*CLAUDE.md missing required section*" }).Count -eq 0
            noSecrets = ($errors | Where-Object { $_ -like "*CLAUDE.md contains potential secret*" }).Count -eq 0
            noUnreplacedPlaceholders = ($warnings | Where-Object { $_ -like "*CLAUDE.md has unreplaced placeholders*" }).Count -eq 0
        }
        agentMd = if ($generatorResult.agentMdContent) {
            @{
                hasHeader = ($errors | Where-Object { $_ -like "*AGENT.md missing required*" }).Count -eq 0
                noSecrets = ($errors | Where-Object { $_ -like "*AGENT.md contains potential secret*" }).Count -eq 0
            }
        } else { $null }
    }
    generatorResult = $generatorResult
}

# Output result
$validationResult | ConvertTo-Json -Depth 10 -Compress
